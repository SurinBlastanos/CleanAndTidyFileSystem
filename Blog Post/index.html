<!DOCTYPE html>
<html>
    <head>
        <title>Tidying the Computer - Describing my File and Registry Scanner Project</title>
        <link rel="stylesheet" href="css/styles.css">
        <link rel="stylesheet" href="css/main.css">
        <link rel="stylesheet" href="css/font-awesome.min.css">
    </head>
    <body>
        <h1>Tidying the Computer - Project Guide for File and Registry Project</h1>
        <center><img src="Resources/display.png" width=50% height=50%></center>
        <p>If you’re reading this, then I’m dead(or the module’s over, one of the two). 
            I have written this guide to stop you from making the same mistakes I did. SAVE YOURSELF!!!</p>
        <p>Jokes aside, hopefully this blog post should explain my work on this project over the past number of weeks, 
            and make it easier for you to make a similar project, or to continue on with this one.</p>
        <hr class="dotted">
        <p>The goal I was given for this project was to “easily tidy and reconfigure a PC,” 
            to be able to put a computer into a tidy state, moving files to better organise the file system, 
            and delete things that weren’t necessary. You may have  noticed the first major hurdle for the project in the last sentence,
             programs tend not to like it when you move their files, so how do we move them in a way that doesn’t break the program and 
             even before that, how do we know which files belong to which program.</p>
        <p>That leads us to the first technical goal of the project, detect which files belong to which program. 
            We’ll talk more about how I achieved most of that goal, and plan to achieve the rest in later sections of this post.</p>
        <p>The next goal is to figure out whether we can edit files belonging to programs to change file paths within them, because if a program is looking for its data_file.txt file under Downloads, and we move it to Documents, 
            the program is going to be annoyed and go on strike, because it can’t find the file.</p>
        <p>If we can change the file paths, we can move all the files that a program requires into a more logical position, and simplify the file system.</p>
        
        <hr class="dotted">
        <p>The main obstacle to this project that was apparent from 
            the start was that there are a few million different ways that a program could install itself onto the file system.</p>
        <p>If every program on windows used the MSI installer, it would be a lot easier, we could wait for an installer to run, and then follow what it does to the file system. However, because we can’t be sure that it will work, we need a more general solution.</p>
        <p>For this project, I settled on a more manual system. I created a file system and registry scanner(more on that later) 
            that are triggered from a local webpage(a webpage was chosen because HTML and CSS make it a lot easier to customise a UI than 
            it would be with a python GUI). The way the scanner would work is that you’d start the scanner and then start an installer 
            program. You’d wait for the installer program to finish, and then stop the scanner. 
            The scanner would then create a file to store the changes that the program made to the file system and registry. </p>
        <p>This allows us to make templates of programs that show us how they install, which could then be used to detect a program on a file system, by checking if the program files we have found exist on it.</p>
        <p>The main goal of the templates is to see how they change when you install a program in different places, so that we can understand how to move the file without breaking the program. This would then allow us to move the programs into a tidier state, decluttering the file system.</p>
        
        <hr class="rounded">
        <h2>Parts of the Project</h2>
        <p>As you will have seen above, this project has a number of stages, some of which I might not get finished. Hopefully this guide will help you to finish the project. I’ll give a description of what’s involved in each area of the project, and then go into a bit more detail on how I’ve approached the stages so far, so that you can understand how the code for this project works and build on it.</p>
        <h3>UI</h3>
        <img src="Resources/ui.jpg" width=20% height=20%>
        <p>For this project, it was important that the program was ready to go whenever the user needed it. To achieve this, this project uses a user interface similar to that of discord, where a small application sits in the system tray, and controls a webpage that is used as the control panel(On Discord, if you press Ctrl-Shift-I, it’ll bring up the inspect element window that is available in most web browsers, allowing you to change what your discord looks like temporarily. It’s not relevant to this project, but it is cool).</p>
        <p>In this project, this will be implemented by telling Windows to start an application on startup. 
            This application will be our system tray application, which I have designed using the WxPython library(<a href="https://www.wxpython.org/">wxPython</a>).</p>
        <p>The system tray application would then start the web application that is built using Python Eel(<a href="https://github.com/ChrisKnott/Eel#:~:text=Eel%20Eel%20is%20a%20little%20Python%20library%20for,can%20be%20called%20from%20Javascript,%20and%20vice%20versa.">Python Eel</a>). 
            Python Eel allows you to link python functions to an HTML webpage, and then creates a local webserver to run the webpage. 
            Using this model allows you to combine the aesthetics of a website with the functionality of a python program.</p>
        <p>The system tray application can then control making the webpage visible and invisible, as it does in discord, allowing the computer’s user to get on with their work without the program cluttering their desktop, and only call the program when they need it.</p>
        <p>You can read my how-to guide on making a Discord style web application, as is used in this project, here: <a href="../How-To-Guide/index.html">Web App Guide</a></p>
        
        <hr class="solid">
        <h3>File System Scanner</h3>
        <img src="Resources/scanner.jpg" width=20% height=20%>
        <p>A large part of this project is the ability to detect when the file system has changed due to an installation. 
            This project uses a python library called Watchdog(<a href="https://pythonhosted.org/watchdog/">Watchdog</a>). 
            Watchdog is great because it has functionality that detects every change in a directory you point it at, 
            and allows you to handle what to do with the data it returns. 
            This saves us the time and complexity of performing complete snapshots of the file system 
            and comparing them to find differences, and allows us to focus on the changes themselves. 
            In this project, we simply point the scanner at the root of the file system, 
            and then use event handlers to store every change that Watchdog tells us about.</p>

        <hr class="solid">
        <h3>Registry Scanner</h3>
        <p>Another major part of this project is scanning the registry for changes.(This part has been the bane of my existence for multiple weeks during this project, so hopefully my explanation later in this blog should save you a lot of googling and reading documentation). Unfortunately, there are not many ways to detect changes in the registry in python, so a good amount of this section of the project is done manually. </p>
        <p>In windows, the registry cannot be actively scanned because it is pretty much constantly in use. 
            What is possible while the registry is in use is to export the Registry Hives(I’ll explain more about them later on) 
            using a built in Windows command module “REG”(<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/reg">reg commands | Microsoft Docs</a>). We are then able to use a python library, Regipy, to interact with the exported hives.</p>
        <p>Regipy is very sparsely documented, so hopefully this guide will fill in some of the gaps in the documentation.(You can find the documentation here: <a href="https://github.com/mkorman90/regipy/">Regipy</a>). </p>
        <p>fill in some of the gaps in the documentation.(You can find the documentation here: Regipy). Regipy allows you to retrieve keys from a registry hive, and so in this project it is used to find out which keys have been changed during an installation.</p>
        <p>The python implementation of regipy does not allow you to find differences between two hives, but each key in the registry has a last modified date within it. This project pulls this date out of the key, and checks whether the key has been changed during the time of the installation. If so, we perform different operations on the key to retrieve the changes from it that had been made during the installation.</p>
        <p>Don’t worry if this doesn’t seem to make sense now, we’ll explain it more thoroughly in the technical section of this blog post. </p>
        
        <hr class="solid">
        <h3>Program Template Files</h3>
        <p>Remember that the main purpose of us scanning the file system and registry is to be able to move programs in the file system without breaking them. In order to do this, we need to know which files belong to each program that gets installed. So once we have detected the changes that a program has made to the system, we need to store those changes so that we know which files need to be moved when we move a program. For this purpose, the scanner in this project creates program template files. We use JSON files for this,  because it is the easiest way to read data into the program. (<a href="http://www.JSON.org">JSON Documentation</a>)</p>
        <p>Each template file we create contains a nested dictionary. Each key in the dictionary is a different type of change on the file system, such as “deleted file” or “HKCU key created” This dictionary allows us to easily store what changes have been made to the file system and registry, which we can then use to move programs without breaking them.</p>

        <hr class="solid">
        <h3>Install Process</h3>
        <p>One of the problems with the fact there are so many ways to install a program is that we will be able to move some programs across the file system without issue, whereas others will break if we move them, because they contain absolute file paths. So our project will not work with all programs, as often it is impossible to change file paths within files because we would need to reverse engineer the programs, which is often illegal. </p>
        <p>In order to ensure that our project is as useful as possible, part of the project is to use our scanner while we install popular programs, and then manually check the template files to see what happens when we change the install location. We also run difference operations on files after they have moved, to see if they have changed. If we find differences, this might show us where the paths are stored in the program. If we could then change those paths, we could then move the program and its files without breaking the program and the law. </p>

        <hr class="solid">
        <h3>Moving Files on the File System</h3>
        <p>This is an area of the project that I have not started work on yet, and so will not be described in the technical section, although I will outline it here, as if I do not finish it within the time of the project, this could be a good starting point for you to continue the project. </p>
        <p>As was explained in the introduction, one of the goals of this project is to be able to move files into a more logical position, in order to clean up the file system. So in this area of the project, we use the template files to move programs without breaking them.</p>

        <hr class="solid">
        <h3>Removing Unecessary Files</h3>
        <p>Another part of the project that I have not started yet is the ability to ask the user which programs on the file system they wish to keep when we tidy the computer, and then to delete any that they do not wish to keep. You may think that this should be easy, we can just call the uninstaller for any programs that we wish to delete and leave it at that. But a big reason that this project is necessary is that program uninstallers frequently leave behind program files and registry entries. So it is our job in this project to “babysit” the uninstaller, by checking that it has removed everything that it created when it was installed, and removing anything that it ignored.
        </p>

        <hr class="solid">
        <h3>Set Up a Custom Installer</h3>
        <p>An additional goal of the project that I have not attempted is the ability to set up a custom installer.</p>
        <p>A user would specify which program they want to install, and our installer would call the program’s installer, and get it to put the program in a logical location, and would then move and alter any files that the installer created in different places. </p>
        <p>This would then allow us to ensure that the file system is always tidy, as we would be in control of how programs installed themselves on the file system.</p>

        <hr class="rounded">
        <h2>Technical Guide</h2>
        <p>In this section, we will go through the technical details of each area of the project, explaining the code and the design desicions that have been made.</p>
        <p>The code we will discuss can be found at my GitHub repository: <a href="https://github.com/SurinBlastanos/CleanAndTidyFileSystem">GitHub repo</a></p>

        <hr class="solid">
        <h3>UI</h3>
        <p>We won’t spend much time on the UI here, as my guide for creating a UI similar to that used in this project can be found here:<a href="../How-To-Guide/index.html">Web App Guide</a>. </p>
        <p> However, that guide talks about generally creating a Discord style web application, so I will briefly cover how the UI in this project is programmed. As mentioned in the previous section, this project uses a Python Eel UI controlled by a wxPython system tray icon. I won’t cover this line by line, as we would be here forever, but I will explain what each section of code is doing, so that you understand how the project functions.</p>
        <hr class="dashed">
        <p>We will start with the HTML code for the UI. As mentioned in the guide for creating a UI of this type, we can build the actual UI using HTML rather than counting pixels to try and make a nice looking python UI. This saves time and makes the project look nicer.</p>
        <p>At this point in the project, the UI is very basic and doesn’t look particularly good, but I have included the Materialize.css framework in the HTML to improve the look somewhat.</p>
        <p>Materialize is a css framework that makes it easy to change how your website looks without dealing with css files yourself. I won’t explain it here myself, as it has no bearing on how the project functions(you can find the documentation for Materialise <a href="https://materializecss.com/getting-started.html">here</a>  if you want to see how it works).</p>
        <p>I will underline Materialize code in yellow, so that you know which parts of the code are purely aesthetic and which are important parts of the project.</p>

        <hr class="dashed">
        <img src="Resources/1.png">
        <p>Let's start with the head of the HTML document. As you can see, we have created two javascript functions within the head. The first of these, startInitialScan() is used to let our scanner program know that we are starting an installation, so that it starts scanning the file system and makes a before snapshot of the registry. The second lets the scanner know that the installation is finished, so that it stops scanning, takes an after snapshot of the registry, compares the two, and creates the program template file that records the changes. </p>
        <p>You will notice that both functions call a method of the “eel” java library. This causes the javascript file to look for any python functions in the web server that have names matching those that it is calling, and to run those functions, returning the results back to the webpage.</p>
        <p>Both of our functions have “alert” functions, which return whichever values are given to them by the python functions. These are only here as a debugging tool, to show us that the functions are executing when they are clicked. As with all debugging code, they should be removed before the project is given to an end user.</p>
        
        <hr class="dotted">
        <img src="Resources/2.png">
        <p>Next, we will look at the body of the HTML application. As I mentioned above, the webpage is sparse at the minute, because the focus of the project has been on the functionality within it. The important thing to note here is that the buttons in the webpage call the functions that we defined in the previous section.</p>

        <hr class="dashed">
        <img src="Resources/pyqt.png">
        <p>Lastly for our UI, we need to look at the WxPython code that runs our system tray application. Luckily for us,
            this code is almost identical to the code in the UI tutorial, and so we require only a couple of minor tweaks to 
            make it fit for use here. As you can see from the screenshot above, we need to add the isAdmin() function and the 
            code that uses it. We need these to ensure that the program is executed with administrator permissions. As well as this,
            we have changed the startWebApp() function to startScanner() and changed the code within it to run our scanner program.
            Apart from those small changes, everything else in the file remains the same, so we are done with our UI.
        </p>



        




        

        <hr class="solid">
        <h3>Python Imports</h3>
        <p>Before we get into the actual scanner functions, I will run through the libraries that this project uses. The comments in the below code should explain what each library is being used for(The project also uses regipy, which is not shown in this screenshot):</p>
        <img src="Resources/3.png">
        <p>Most of these libraries are built into python, but there are a few that we will need to install ourselves, Watchdog, Eel, wxPython and Regipy. I will put the install commands below, type these into the command line and they should install(This requires you to have python 3, if you do not, follow this guide to get it installed: <a href="https://realpython.com/installing-python/">Python Installation Guide</a>) : </p>
        <p><b>Watchdog</b>: pip install -U watchdog</p>
        <p><b>Eel</b>: pip install eel</p>
        <p><b>wxPython</b>: pip install -U wxPython</p>
        <p><b>Regipy</b>: pip install regipy</p>

        <hr class="solid">
        <h3>File Scanner</h3>
        <p>Our file scanner code is contained within the main server program so that it can easily access the variables it requires. It is used to detect any changes in the file system made during installation, and store the location of those changes. This allows us to ascertain where a program is installing its program files.</p>
        <hr class="dashed">
        <p>The first set of four functions that we need for our file scanner are the event handler functions. When Watchdog detects a type of change in the file system, it creates an event. This is very useful for us, as Watchdog allows us to create functions to handle these event types, so that we are in control of what we use the event for in our program. For our project, we have handlers for four events, the file creation event, the file deletion event, the file modification event and the file move event. We will run through one of them here, as they are all very similar:</p>
        <img src="Resources/X.png">
        <p>A lot of the functions in this project contain print statements and returns that aren’t necessary for the program, but make debugging the program a lot easier. I have commented in the program as to where these are.</p>
        <p>Watchdog passes the file path of any event it detects to our handling function, which allows us to append it to the “files_created” list. This list is a global variable that holds all of the files that the installation has created. You will see that this only takes about two lines of this function. The rest of the function forms part of our file filter.</p>
        <p>Using this filter, the file scanner omits certain files that are passively generated by the operating system, which would give us false positives in our template files.</p>
        <p>Watchdog allows you to specify a list that it uses as a filter, ignoring any files within it. However,Watchdog makes you choose whether you want to omit exact file names, or directories from your search. For the most part, we want to ignore exact files, in case someone writes a program that randomly decides to store its data in the Downloads folder, for example. But in certain cases, we also want to ignore certain directories that create lots of temporary files</p>
        <p>For example, Microsoft Edge's UserData folder created a lot of temporary files. So most of this function is omitting results from that folder.</p>
        <p>Admittedly, this is not the best way of doing this. A much better solution would be to check if the file path matched a partial path from a list of program files that do the same as Edge, that we would have to curate manually. This could be a way for you to move this project forward, as in the interests of time within the project, I haven’t implemented this better solution.</p>
        <hr class="dotted">
        <img src="Resources/4.png">
        <p>The next function we need for the file scanner is the “triggerFileScan()” function. The purpose of this function is to set up the watchdog scanner. We’ll take this function in parts, as it has to handle a lot of setup required to scan the file system.</p>
        <hr class="dotted">
        <img src="Resources/5.png">
        <p>This line creates a new thread, which runs the “getInitialCopyOfRegistry()” function. This function creates the registry files used as the initial registry snapshot.</p>
        <p>We run it as a thread because it takes some time to create the files required, and this would hang the main program until it was finished.</p>
        <hr class="dotted">
        <img src="Resources/6.png">
        <p>This section is used to store the time that the installation starts at. We use this to search the registry for keys. If the key has a modified date after this date, then it was created during the installation that we’re tracking, and so we want to know about it. We store this datetime as a global variable, so that we can access it from the registry function later on.</p>
        <hr class="dotted">
        <img src="Resources/7.png">
        <p>The next section that we will look at sets up the file scanner. <b>*Flight Attendant voice*</b> If I could direct your attention to the sixth line of this screenshot, this is where we create a handler for the file system scanner.</p>
        <p>In the first four lines, we specify the parameters for our handler. I’ll explain the four parameters we are using:</p>
        <ul>
            <li><b>Patterns</b>: this parameter is used to tell the handler what patterns we are looking for(such as file type). As we want to see all files in this project, we use the “*” wildcard to tell the handler that we want to see all files that change on the system</li>
            <li><b>Ignore_patterns</b>: This parameter specifies files that we don’t want to scan. In this project, we want to ignore any files that are passively generated by the operating system. The repository for this project includes a couple of files containing paths that we want to ignore, and so we use the refactorPassiveFiles module, which I will explain later on, to retrieve this. For now, all we need to know is that this function returns a list of file paths that we want to ignore, which we pass to the handler</li>
            <li><b>Ignore_directories</b>: Pretty self-explanatory, this boolean tells the handler whether or not to ignore folders in the file system</li>
            <li><b>Case sensitive</b>: This determines whether the path names we pass in patterns and ignore_patterns should be treated as case sensitive</li>
        </ul>
        <p>In the last four lines of this section, we assign the event handler functions that we created above to the file scanner’s events, allowing us to handle the events created by the scanner.</p>
        <hr class="dotted">
        <img src="Resources/8.png">
        <p>The last section of our triggerFileScan() function starts by specifying the path that the file scanner should scan. Because we want to scan the whole file system, we specify the root of the file system. You may have noticed that this does not take into account computers with multiple drives. The program could be refactored so that it checks whether the computer has a SATA drive, and then runs a scanner for each drive, but I have not yet attempted this, so this could be something you could do to advance the project.</p>
        <p>Next, we create an observer object and set it as a global variable. The observer is the object that does the actual scanning of the file system, it uses the information we have provided in the “myEventHandler” object to decide what to ignore and what to trigger an event for.</p>
        <p>We pass the observer the event handler, the path we want to scan, and a boolean for recursive, this determines whether the scanner checks just the specified folder, or whether it scans subfolders as well. Because we want to scan the entire filesystem, we set this to true.</p>
        <p>We then call the startFileSystem function in a thread. That function is used to start the file scanner that we have set up in this function. We start “startFileSystemScan” in a thread, because it is a function that continues until terminated, so it would cause the program to hang if it was executed in the main program.</p>
        <hr class="dashed">
        <img src="Resources/9.png">
        <p>The last function that we need for our file scanner is startFileSystemScan(). This function starts the scanner that we defined in the last section. It also defines an end condition for the scanner, a KeyBoard Interrupt. This is not how we terminate the scanner in our program, but it does give you a way to end the scanner if it is being unresponsive during a test.</p>

        <hr class="solid">
        <h3>Registry Scanner</h3>
        <p>We will now take a look through the functions of our registry scanner program. We’ll start with the functions contained within our main program, and then go through the registryScanner program that contains our functions that do the actual scanning.</p>
        <hr class="dashed">
        <img src="Resources/10.png">
        <p>The first function that we should look at is terminate_file_scan_and_start_registry_scan() (sometimes my genius for function names knows no bounds). The purpose of this function, as may be apparent from its name, is to stop the file scanner and start the registry scanner</p>
        <p>Like the triggerFileScan() function, this function is prefaced by “@eel.expose” which allows it to be triggered from our webpage. </p>
        <p>As you can see, the function calls the handler for our file scanner, and ends its scanning process. </p>
        <p>The third and fourth lines in this function are ones that we need to pay close attention to. As you can see, we are storing the results of the beginRegistryScan() function(which we will look at shortly) in a number of variables, and then passing these variables to the create_dict_for_json function. Each of the variables that we use here stores created key values, modified key values and deleted key values for a hive of the registry.</p>
        <p> The Windows Registry contains five primary hives, but we only need four of them, HKCC,HKCU,HKLM and HKCR. This is because the fifth key, HK Users, although it technically stores information on all users on a system, it usually only stores information for the current user, which is covered by HK Current User, so HK Users is redundant for our purposes. You may notice that we have hives here called hardware, SAM and security, but no hive called HKLM. This is because the HKLM hive is constantly in use, so it cannot be saved. However, each of the five subkeys of HKLM can be saved, and so we scan each of them for changes, and together that covers the entirety of the HKLM hive.</p>
        <p>In this version of the program, we are only using three of the five subkeys of HKCU, HARDWARE, SAM and SECURITY, and we are not scanning the HKCR hive either. This is because it takes more than 10 minutes to scan these hives and subhives, so they have been omitted for testing. In the final version of the project, they would be included.</p>
        <p>Don’t worry if this sounds confusing, the Windows Registry is not well documented at all, and it took a lot of trial and error to figure this stuff out, so I don’t expect you to understand all of this straight away. I will link some of the resources I used to figure out how the registry works at the end of this blog, so you can read through those to get a better understanding of the registry scanner. </p>
        <p>Luckily, we don’t need a perfect understanding of the registry in order to scan it, we just need to be able to detect changes in it. “How do we actually detect changes in it?”, you may ask. We’ll go through that in a minute.</p>
        <hr class="dashed">
        <img src="Resources/11.png">
        <p>Before we get into the actual scanning, we need to look at the function at triggers the scanner. We won’t spend long on this one, as it is fairly repetitive.</p>
        <p>It starts by retrieving the installation’s start time that we recorded before we started scanning the file system. Then, the function “getCopyOfRegistry()” creates the registry snapshot files that we will scan.</p>
        <p>We use the same function to scan each registry hive, detect_registry_changes, but we pass it the name of the hive that we want to scan, as well as the current time, and the name of the pre-installation snapshot for that hive. The function then returns any changes that were made during the installation of the program we are monitoring, which we then pass back to the function we looked at above.</p>
        <hr class="dashed">
        <img src="Resources/12.png">
        <p>If you’ll follow me out of the main program, and through the door marked “registryScanner.py”, we’ll take a look at how we scan the registry in this project. </p>
        <p>We’ll start with the functions that we use to create a before and an after snapshot of the registry.</p>
        <p>For this, we use the command line command “REG.exe”. There are multiple ways to store data from the registry using this command, but regipy(the python library we will use to scan the registry files) can only work with .dat files, which are created with the REG SAVE command, so that is the one we use here.</p>
        <p>As you can see, the copy files of the registry that we make before installation are named XInitial.dat, while the after files are just named X.dat. This is to differentiate between them, as we need to access both within the scanner. </p>
        <p>The /y parameter that we place on the end of each command ignores the “are you sure you want to proceed” line, which allows these functions to run without user input.</p>
        <hr class="dashed">
        <img src="Resources/13.png">
        <img src="Resources/14.png">
        <p>The next function on our whistle-stop tour of the project is the main function in our registry scanner. This is a large function, so we will go over it a section at a time. I have highlighted each section in a different colour to help clarify what section I am talking about.</p>
        <p>The first section, within the yellow box, is the initialisation of data we will need for the scanner. It creates two “RegistryHive” objects, which are used to handle the registry files that we created in the previous section.</p>
        <p>The section in the green box iterates through each key in the hive we are scanning. For each key, it pulls its timestamp, and converts it to the same type as the timestamp we created at the start of the installation process(this allows us to compare the timestamps). To pull the timestamp, we convert the registry key to a string, and use python’s re module to search the string for the word “timestamp”.</p>
        <p>The red section calls a function called registry_filter(), that we will go over later in the blog, and passes it the name of the registry. registry_filter()  returns a list of registry keys that we want to ignore in our scanner, as they are changed by the file system rather than by an installation.</p>
        <p>The red section then checks to see if the key has been edited since we began installation of the program we’re monitoring. It does this by checking the timestamp that we have pulled from the key. If it is more recent than the timestamp we created at the start of installation, then the key has been changed during installation.</p>
        <p>If this is the case, we want to be able to store the changes that have been made to the key. In order to do this, we need to uniquely identify the key. From research, I have found that the name of a key is not unique, so we use the key’s path to identify it. The red section retrieves the path the same way we retrieved the timestamp.</p>
        <p>Finally, the red section checks whether the key is in our ignore list.</p>
        <p>Once we know that a key has been changed, we need to know what changes have been made to it. To do this, we need to retrieve its values. This is what the white section of this function does, it pulls the values out of the key as a dictionary.</p>
        <div class="boxed">
            <p><b>Terminology</b></p>
            <p>Okay, at this point, I should go over a little bit of terminology, or everything that follows will sound like gibberish. As already mentioned, the Windows Registry contains 5 Registry Hives, and each of these hives contain sub hives made up of keys. Each key in the registry holds settings for Windows, or for programs on the computer. This is where it gets a bit confusing. A key contains variables that specify the settings that have been created. Unfortunately, Windows calls these variables “values”. That’s not bad on its own, but the problem is that each of these variables contain a name, and data, and Windows also calls the data “values”. So if a program updates the data within a key, it is changing a value value, which makes talking about the registry very confusing. To make it simpler, I will refer to the key variables as variables, and the data within them as values.</p>
        </div>
        <p>The final important part of the function is the blue section. This section calls different functions that we will look at soon.</p>
        <p>The function that I have, in an amazing blaze of creativity, called check_for_key_creation_and_deletion(), takes the key we pass to it, and checks it in both the before and after registry snapshot. It can detect three types of difference, variables that have been created in the installation, variables that have been deleted, and variables that have been modified. It returns a list for each type of change. </p>
        <p>We pass these lists to the create_x_key_dictionary() functions, which return dictionaries that store precisely what changes have been made to each variable.</p>
        <p>Lastly, in the pink section, we return the dictionaries of changes that we have created.</p>
        <hr class="dashed">
        <img src="Resources/15.png">
        <p>Next, we’ll look into the check_for_value_creation_and_deletion() function we mentioned briefly above. This function compares the before and after snapshot of a registry key, and determines how it has changed over the course of the installation.</p>
        <p>The first two loops in this function create lists that hold the names of each variable within the key.</p>
        <p>The next loop is slightly more complicated, so I’ll run through the logic it follows. Firstly, it iterates through each variable name from the after snapshot, and checks whether the same name exists in the before snapshot. If the name appears in both snapshots, then the name has not been created or deleted during the installation, so we store it in a list of variable names that appear in both snapshots. If it doesn’t appear in the before snapshot, then it has been created during the installation, we save it in the names_only_in_modified list. As well as this, if the name appears in both hives, we increment a variable that is counting how many names appear in both lists. Once we have iterated through the names from the modified list, we check if this incrementer variable is equal to the number of names in the list of names from the before snapshot. If it is, then every name in the before snapshot was also in the after snapshot, and so we don’t need to go through the before snapshot. But if the incrementer is less than the number of names in the before snapshot, then there are names in the before snapshot that don’t appear in the after snapshot, and so we iterate through the before snapshot names to see which ones only appear in the before snapshot(if a name only appears in the before snapshot, then it has been deleted during installation), and store them in the names_only_in_initial list.</p>
        <hr class="dashed">
        <img src="Resources/16.png">
        <p>The next three functions that we need for the registry scanner create dictionaries that store enough data about key variables to recreate them if we needed to. They are very similar, and so going through one of them should be enough to explain how they work. </p>
        <hr class="dotted">
        <img src="Resources/17.png">
        <p>The purpose of this function is to create a dictionary that stores key variables and their values that have been deleted during installation. It iterates through the key we pass to it until it finds the variable names that have been deleted during the installation. It stores the value of each variable against its name in a dictionary of deleted keys.</p>
        <hr class="dashed">
        <img src="Resources/18.png">
        <p>Unfortunately for our project, Windows passively updates the registry, which gives us false positives. </p>
        <p>During my research I was unable to find a way to differentiate between OS changes and program installation changes(Windows doesn’t keep a list of registry keys that it changes, and I’m nearly certain that at this point, Windows is so abstracted that no one knows exactly what its doing in the background). </p>
        <p>To counter this, I have run the registry scanner while no program was being installed in order to create a list of registry keys that Windows changes.</p>
        <p>This function pulls this data out of the JSON file that the scanner stores data in, and stores it in a single list of keys that we can then ignore.</p>

        <hr class="solid">
        <h3>Program Template Files</h3>
        <p>The final part of the project that I have programmed so far is the program template files. As we mentioned in the intro section of the blog, these are used to store the output of the scanner, the changes that an installation has made to the file system. Luckily, this part of the project isn’t particularly difficult, so we will cover it briefly.</p>
        <hr class="dashed">
        <img src="Resources/19.png">
        <p>This function takes the outputs from our file system and registry scanners, and stores them all in a single dictionary. Currently, there are three registry (sub)hives not being scanned or stored, as we previously mentioned, SOFTWARE, SYSTEM, and HKCR, as these take too long to scan and so massively increase testing time. These should be added once everything else in the project has been tested.</p>
        <hr class="dashed">
        <img src="Resources/20.png">
        <p>The last function we will look at here is the save_json()  function. (We haven’t looked at the refactorPassiveFiles module, but it functions very similarly to the registry filter we discussed above, so there is no need to go over it). </p>
        <p>The function is pretty self explanatory, the only thing I want to mention is the fact that one of the parameters for the function is template_name. I have not yet implemented this functionality, but the control webpage should ideally have a textbox that allows the user to input the name of the program they are installing, so that we can name the template file appropriately.</p>

        <hr class="rounded">
        <h2>Conclusion and Useful Links</h2>
        <p>That’s pretty much it for this blog post. We've covered the progress that has been made in this project up to now, and discussed how to move the project forward. Hopefully it has given you enough insight into the project to carry it forward. Before we finish, I’ll give you a few guides that I found useful during this project, to give you more insight into the workings of the project.</p>
        <h3>Registry</h3>
        <p><a href="https://stackoverflow.com/questions/130763/request-uac-elevation-from-within-a-python-script">windows - Request UAC elevation from within a Python script? - Stack Overflow</a> - Explains how to get administrator access in python, required for registry operations</p>
        <p><a href="https://janakiev.com/blog/python-shell-commands/">How to Execute Shell Commands with Python - Parametric Thoughts</a> - Shows how to execute commands in python, we use this to make copies of registry hives</p>
        <p><a href="https://github.com/mkorman90/regipy">GitHub - mkorman90/regipy: Regipy is an os independent python library for parsing offline registry hives</a> - regipy Documentation</p>
        <p><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users">Windows Registry For Advanced Users</a> - Windows Registry Documentation</p>
        <h3>Eel</h3>
        <p><a href="https://github.com/ChrisKnott/Eel">GitHub - ChrisKnott/Eel: A little Python library for making simple Electron-like HTML/JS GUI apps</a> - Eel documentation</p>
        <h3>WxPython</h3>
        <p><a href="https://stackoverflow.com/questions/6389580/quick-and-easy-trayicon-with-python?rq=1">wxpython - Quick and easy: trayicon with python? - Stack Overflow</a>- Gives a few examples of simple system tray icon programs</p>
        <p><a href="https://gist.github.com/thomaschaaf/7344891">Basic wx Application which shows a snake in the System Tray and on open and close of the context menu displays a message in the console. · GitHub</a> - More advanced system tray application</p>
        <p><a href="https://realpython.com/python-gui-with-wxpython/#getting-started-with-wxpython">How to Build a Python GUI Application With wxPython – Real Python</a> - More general guide on making a GUI with wxPython</p>
        <h3>File System</h3>
        <p><a href="https://python-watchdog.readthedocs.io/en/v0.10.3/">Watchdog — watchdog 0.10.3 documentation</a> -Watchdog Documentation</p>
        <p><a href="https://stackoverflow.com/questions/51132783/why-its-not-recommended-to-use-ids-in-wxpython">Why it's not recommended to use IDs in wxPython? - Stack Overflow</a> - Useful Information on IDs in wxPython</p>
        <p><a href="https://stackoverflow.com/questions/41442259/wxpython-does-not-have-adv">python - wxpython does not have 'adv' - Stack Overflow</a> - WxPython has released multiple versions over the years, some of the tutorials you look at may be using an older version than we want</p>
        <h3>JSON</h3>
        <p><a href="https://www.programiz.com/python-programming/json">https://www.programiz.com/python-programming/json</a> - explains how to use JSON structures in python</p>

        
    </body>
</html>